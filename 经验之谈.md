# JS经验

##  reduce的另类用法

```js
var str = 'ljkafhklsdfhaskfas'
var result = str.split('').reduce((a,b) => (a[b]++ || a[b] = 1), a), {})
```

其中还使用了**括号运算符**，未简化之前的代码：

```js
var str = 'ljkafhklsdfhaskfas'
var result = str.split('').reduce((a,b) => {
    if (a[b]) {
        a[b]++
    } else {
        a[b] = 1
    }
    return a 
}, {})
```



## 输入框拼写合成

```js
const inp = ducument.querySelector('input')
let isComposite = false;

inp.addEventListener('compositionstart', () => {
    isComposite = true
})

inp.addEventListener('compositionend', () => {
    isComposite = false
})
```

然后在执行搜索，或者发送事件之前，去判断这个值就行了







## 限制并发请求数量

```js
function concurRequest(urls, maxNum) {
  return new Promise((resolve) => {
    if (urls.length === 0) {
      resolve([]);
      return;
    }
    const results = []
    let index = 0
    let count = 0;
    
    async function request() {
      const i = index
      const url = urls[i];
      index++;
      try {
        const res = await fetch(url);
        results[i] = res;
      } catch (error) {
        results[i] = error;
      } finally {
        count++;
        if (count === urls.length) {
          resolve(results)
        }
      }
    }

    const times = Math.min(maxNum, urls.length)
    for (let i = 0; i < times; i++) {
      request()
    }
  })
}
```

## 滚动到可视区域

```js
$0.scrollIntoView()

$0.scrollIntoView({behavior: 'smooth'})

$0.scrollIntoView({behavior: 'smooth', block: 'center'})
```

## 求数组中的最大值和最小值

```js
var arr = [1, 66, 3, 99, 4];
var max = Math.max.apply(Math, arr);
var min = Math.min.apply(Math, arr);
```



## 避免通过new来调用函数

```js
function a () {
  if (new.target) {
    throw new Error("can't invoke with 'new'")
  }
}
```

## 判断页面是不是在移动端设备上打开的

```js
const onMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
```

## 创建一个概率事件

```js
if (Math.random() > 0.99) {
    // 1% 的概率
}
```



## 正则表达式

### 正则表达式前瞻和边界

```js
cosnt str = '1345724912356123'
// 要求把数组做千分位
const result = str.replace(/(?=\B(\d{3})+$))/g, ',')

// 前瞻： /(?=匹配项)/g  这样就可以得到符合匹配项的前面位置
// 边界	B表示边界， \B表示非边界
// +$ 	表示出现1次或者多次


```


### replace方法

```js
let con = prompt('输入要检测的内容， 支持正则')
let reg = new RegExp(con, 'g')
let div = document.querySelector('div')
div.innerHTML = div.innerHTML.replace(reg, search => {
    // 在这个方法中可以对匹配到的数据进行处理，然后return出去的东西就是替换的东西
    return `<span style="color: red">${search}</span>`
})
```





## 监听页面的隐藏和显示

```
document.addEventListener('visibilitychange', function () {
  console.log('23423')
  if (document.hidden) {
    console.log('页面被隐藏');
  } else {
    console.log('页面被显示');
  }
})
```



## Ts 类型

| 类型  | ts类型              |
| :---- | :------------------ |
| style | React.CSSProperties |
|       |                     |
|       |                     |



## 乱序假文

```
https://picsum.photos/200/300
```

jw5    五个中文字

lorem1000  一千个英文单词



## 资源提示符

+ <script>    

   + async :   异步获取此js文件，然后获取到了之后立即插队执行此文件

   + defer： 异步获取此js文件，然后在获取到了文件之后，也会等待所有资源执行完毕了之后，才执行它

     （type="module" 默认是defer） 

 + <link>
   + Preload:  异步加载css或者js文件，优先级比较高
   + Prefetch:  空闲到时候才会加载请求这个文件



## 浏览器标签页相互通信

```js
<script>
  const channel = new BroadcastChannel('channel');
  channel.onmessage = function (event) {
    console.log(event.data);
  }
  setInterval(() => {
    channel.postMessage('径向展开图片')
  }, 1000)
</script>
```






# css经验

## flex布局吃掉更多的宽度问题

弹性盒子均匀分布的时候，因为item盒子的内部内容多而撑大了宽度，这个时候可以设置

```css
.item{
    flex-grow: 1;   // 增长为1
    flex-basis: 0;  // 起始宽度为0  默认是auto的
    flex: 1 0 0;  // 合并起来可以写成这样
}
```



## 磨砂玻璃的效果

```
filter: blur(5px);  // 不要这样写，因为这样写模糊的是本身，包括本身的内容也模糊了
```

```
backdrop-filter: blur(5px) // 这样就不会模糊自己，而是模糊它盖住的后面的东西
background: rgba(255, 255, 255, 0.4)
```



## 彩色照片灰度处理效果

在一张照片之上绝对定位或者fixed定位一个盒子

```css
.modal {
	backdrop-filter: grayscale(1) // 灰度设置1
	transition: 2s;
	right: 0 // 这里设置right就会向右边过度显示彩色
}

.container: hover .modal {
	width: 0;
}
```

## 文字描边

```css
-webkit-text-stroke: 2px #fff
```



## 特别小的文字

```css
span{
    display: inline-block; // 需要设置成块级元素，因为缩放只对块级元素有效果
    font-size: 12px;
    transform: scale(0.5);
    transform-origin: left center; // 默认是在中心进行缩放的，所以要设置缩放参照点
}
```



## 蒙版遮罩

```css
.test{
    -webkit-mask-image: 
      linear-gradient(to right,
        #000,
        #000 3px,
        transparent 3px,
        transparent calc(100% - 3px),
        #000 calc(100% - 6px),
        #000 100%
      )
        ,
      linear-gradient(to bottom,
        #000,
        #000 3px,
        transparent 3px,
        transparent calc(100% - 3px),
        #000 calc(100% - 6px),
        #000 100%
      )
    ;
    -webkit-mask-position: center;
    -webkit-mask-repeat: no-repeat;
}
```



## 效果过度时长处理

```
transitionz: all 2s ease;
```



## 滚动条样式美化

```css
&::-webkit-scrollbar {
  width: .1481rem;
}
&::-webkit-scrollbar-thumb{
  background: transparent;
}
&:hover::-webkit-scrollbar-thumb {
  border-radius: .1481rem;
  background: rgba($color: white,$alpha: 0.6);
}
&::-webkit-scrollbar-track {
  border-radius: 0;
  background: transparent;
}

// 以下这样可以避免滚动条的出现和隐藏会影响到边距

useLayoutEffect(() => {
	const adjustMarginBasedOnScrollbar = () => {
		const scrollableDiv = topRef.current;
		let padding = '.2963rem'
		if (scrollableDiv.scrollHeight > scrollableDiv.clientHeight) {
			padding = '.1481rem'
		}
		scrollableDiv.style.paddingRight = padding
	};

	window.addEventListener('resize', adjustMarginBasedOnScrollbar);
	adjustMarginBasedOnScrollbar()

	return () => {
		window.removeEventListener('resize', adjustMarginBasedOnScrollbar);
	};
}, [])
```

## Img 图片长宽比固定

```css
background-image: url('./imgs/G14.jpg');
background-size: cover;
background-position: center;
```

## 阴影效果

```css
filter: drop-shadow(0px 0px 20px #000);
```

## 鼠标样式变化

```css
cursor: pointer; 变成小手

cursor: move; 变成移动十字架

cursor: not-allowed; 变成禁止点击
```



## 同时选中多个className

```css
div[class^='dingkaile']{
	样式
}
```



## 选中第开始个到第结束个元素

```css
&:nth-child(n + 开始):nth-child(-n + 结束)
```



## 选择前面几个元素

```css
&:nth-child(-n + M)   // 选中1 2 3 ... M 
```



## 选中某个元素之后的所有元素

```css
 &:nth-child(n + M)   // 选中的是第M个开始直到最后一个元素 
```





## 去掉input框获得焦点的时候的蓝色框

input{

Outline: none;

}	



## 透明色的别样写法

```
rgba($color: white, $alpha: 0.1)
```

## 固定长宽比

```
定义长度，或者宽度，另一个则auto
aspect-ratio: 16/9
```

## 动画的停止和播放

```css
css属性： 	animation-play-state
属性值： 	paused、 running
```

## 滚动平缓样式

```css
scroll-behavior: smooth
## img图片长宽比保真

```css
object-fit: cover;
```

## 裁剪背景

```css
background-clip: content-box  | padding-box  | border-box
```



## 径向裁剪展开图片

```css
&::after,
&::before {
  content: '';
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  border-radius: 50%;
}

&::before {
  background: rgba(0, 0, 0, 0.6);
}

&::after {
  transition: 3s;
  background: inherit;
  clip-path: circle(0% at 50% 50%);
}
&:hover::after{

  clip-path: circle(50% at 50% 50%);
}
```





## grid布局

```css
// 可以设置最小高度和最大高度,这样即使有更多的盒子，也不会挤压空间，相反，盒子不够的时候，也不会拉伸盒子来撑满父盒子空间
grid-template-rows: repeat(2, minmax(50%, 60%));  

// 控制间距
row-gap: 10px;
column-gap: 10px
gap: 20px 10px

//控制div所在的位置
grid-row-start: 3; // 如果不写，就从默认的行位开始
grid-row-end: span 1; // 占用一行
grid-row-end: 4; // 到第四条线结束
grid-row: 1/span 1; // 从第一条线开始，占用一列
grid-row: 3/4; // 从第三条线开始，到第四条线结束
grid-row: span 1 // 从默认的位置开始，只占用一行

grid-area: 1/1/3/2;  // 行起、列起、行终、列终

// 划分区域
grid-template-rows: 60px 1fr 60px;
grid-template-cloumns: 60px 1fr;
grid-template-areas: "header header" // 如果有不需要划分区域的地方，可以用占位符". ."
	"nav main"
	"footer footer";
// 使用区域
.dingkiale{
    grid-area: header
}

// 改变布局流向
grid-auto-flow: row // 这样就从左边开始，向下流
grid-auto-flow: row dense // 这样就会把中途跳过的空隙用后面没有指定所在位置的盒子填上

// 当子内容不多，占用不满父区域的时候，需要引入空间布局
justify-content: space-evenly //均匀的水平分布
align-center: center // 垂直居中
place-content: space-evenly center // 合并写法 先垂直 后水平 相同值的时候只写一个

// 字盒子在栅格中的位置
justify-items: start end center stretch(默认拉伸撑满) // 水平方向
align-items: start end center stretch(默认拉伸撑满) // 垂直方向
place-items: start center // 合并写法
如果是默认拉伸的时候，给了子盒子一个固定宽高，那就没有意义了

// 单独的控制某一个子盒子的位置：
justify-self: end
align-self: start
place-self: start center // 合并写法

```

## 动画交替的反向变化

```css
animation: shadowing 1s infinite alternate;
```



## 图层混合模式

```css
mix-blend-mode: screen;  // 本图层是白色的地方，就显示白色，黑色的地方就显示透过它看它下面的内容
```



## has选择器

```css
.father:has(.son:nth-child(4):hover){
  background: red
}
```

这样的效果是： 当第四个子元素被hover的时候，就会给父div更改背景色，移入别的子元素就不会更改背景色



## 自定义css属性

由于动画只能更改属性，不能更改变量，当有多个动画作用于同一个css属性的时候，就可以自定义css属性，然后引用到被更改的相同的css属性之上。

再更改自定义的css属性就行了，这样就可以做到多个动画作用于同一个css属性而不被覆盖。

```
定义：
@property --x{
	syntax: '<length>';
	initial-value: 0px;
	inherits: false;
}

使用：还是像使用一个变量一样的
transform: translatex(var(--x))
```

一般没有涉及到动画担心覆盖了同一个样式属性的，就不用这么做

平时直接使用定义属性就可以了

因为动画中更改变量不会起作用，只有更改css属性才会起作用



## 旋转

+ transform： rotate（45deg）； // 旋转角度
+ transform-origin: center; // 旋转的原点



## SVG

可以给里面的元素设置单独的class属性，也可以给里面的单独的元素设置动画

``` xml
<svg width="100%" height="100%"> // 尺寸可以设置长宽比
    <circle id= "mycircle" cx="50" cy="50" r="50"/> // 圆心坐标， 半径
</svg>

<svg width="100" height="100" viewBox="50 50 50 50"> // 左上角的坐标，宽度、高度
	<circle id= "mycircle" cx="50" cy="50" r="50"/>
</svg> // 这样只会看到右下角的四分之一圆
```

如果不指定svg的width 和height的话，那么就是默认为所在html元素的宽高 

### circle

可以给<svg> 中的 <circle> 标签设置c lass属性，通过css去控制样式

+ fill:  填充色
+ stroke： 描边色
+ stroke-width： 边框宽度



### line 和 polyline和polygon

```xml
<line x1="50" y1="50" x2="350" y2="300"></line>
<polyline points= "50,120  30,99 91,200 40,22"></polyline>
<polygon points= "50,120  30,99 91,200 40,22"></polygon>
```

+ stroke： 填充色
+ strock-width： 线宽度
+ fill： 在画折线的时候，会自动填充黑色，所以想要一条不污染的折线需要设置为 none

polygon是绘制多边形的。 points指定经过的点，将这些点连接起来就是多边形了

### react

+ x: 左上角横坐标
+ y: 左上角纵坐标
+ height: 高度
+ width: 宽度



### ellipse

+ cx: 椭圆中心横坐标
+ cy: 椭圆中心纵坐标
+ ry: 椭圆的长半径
+ rx: 椭圆的短半径  

### path

+ d： 绘制的路径
  + M：相对于上一个坐标的位置移动 x,y
  + L： 移动到x,y
  + H：移动到x
  + V： 移动到y
  + Z： 有则表示闭合（终点和起点连接）

三个属性用大小写都可以



### text

唯一不一样的就是用fill来改变字体的颜色

### use

复制一个形状

+ x 相对于之前的该形状的左上角确定现在的左上角
+ y 同上

```html
<svg> 
    <circle id="dingkaile" cx="5" cy="5" 4="5"></circle>
    <use href="#dingkaile" x="10" y="0" fill="white"></use>
</svg>
```

可以给新复制出来的形状重新配置样式



### g

g标签用于将多个形状组成一个组，方便复用



### defs

申明标签， 后续不通过use来引用它的话，它就不会显示出来

<svg> 
    <defs>
        <g id="dingkaile">
            <circle cx="5" cy="5" 4="5"></circle>
            <polyline points= "50,120  30,99 91,200 40,22"></polyline>
        </g>
    </defs>
    <use href="#dingkaile" x="10" y="0" fill="white"></use>
</svg>



# React备忘

## 合并className

```
import clsx from 'clsx';
或者用classnames 来替换也行，写法是一样的

<div className={
  clsx("class1", 'class2',{
  	'classMaybeExist1': boolean1,
  	'classMaybeExist2': boolean2,
  })
}>
```



## useContext

```tsx
import { ReactNode, createContext, useContext, useState } from "react"

const dingkaileData = {
	name: '丁凯乐',
	age: 28
}

type IDingkaileData = typeof dingkaileData

interface IDingkaileContext {
	dklData: IDingkaileData,
	setDklData: React.Dispatch<React.SetStateAction<IDingkaileData>>
}

export const DingkaileContext = createContext<IDingkaileContext | null>(null)

interface IDingkaileProvider {
	children: ReactNode
}

export function useDingkaile() {
	const dkl = useContext(DingkaileContext)
	if (dkl === null) {
		throw new Error('使用 useDingkaile 必须在DingkaileProviden内容当中')
	}
	return dkl
} 

export default function DingkialeProvider({children} :IDingkaileProvider) {
	const [dklData, setDklData] = useState(dingkaileData)

	return <DingkaileContext.Provider  value={{dklData, setDklData}}>
		{children}
	</DingkaileContext.Provider>
} 
```







# Vue备忘

##  vetur设置

下载vetur插件  这样就会有彩色的代码了

然后setting  => 打开设置文件  => 在文件末尾加上

```json
 "vetur.validation.script": false
```

这样vue文件没有写默认导出也不会报错了



# 踩坑之路

## react全局样式

==**正确写法**==

```css
//单个：
:global(.ant-tabs) {
  background: green;
}

//多个：
:global{
  .ant-tabs{
    background: green;
  }
}
```

而不是：

```css
&:global

::global

&::global
```



## 资源加载不出来的可能原因

有可能是走了缓存，所以没有刷新文件，所以在开发的时候，一定要记得把Network 中的Disable cache给勾选上



## 设置了line-height却没有垂直居中

原因是行高是依据盒子的height居中对齐的话，这个height是包含border和padding的。如果有border和padding就会影响到ling-height中心线的位置。需要减掉border和padding的高度。

## img间距无故变小

```html
<img/>
<img/>
<img/>
这种写法因为有换行符，所以会有一个空格在图片之间。所以这样的图片宽度是比较大的

<img/><img/><img/>
这样连着写之后，间距就变小了，因为去掉了它们之间的空格

这是由于img是行盒布局的原因。要处理这个问题，可以给图片添加 float：right
或者给父盒子添加 flex布局
```

## 设置：first-child没有选中

检查它是否是当前域中的第一个元素

我正式前面有一个h1，然后后面才是.item

然后 .item:first-child 没有选中

这个时候可以通过:first-of-type 来选中



# 调试经验

## 断点调试

<img src="./imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95.jpg" alt="浏览器调试截图"  />



+ 第一个按钮是执行完这一行（下一步）

+ 第二个按钮是进入到这一行中执行的函数内部（进入函数）

+ 第三个是跳出当前函数，返回到调用处（离开函数）
+ 下面是显示所有的断点。可以在此打开和关闭所选断点
+ watch中是可以套用作用域中的变量来进行运算监控，或者直接监控的。也可以输入某个作用域中的函数，查看该函数的返回值



## 获取节点方式

```js
// 相当于ducument.querySelector()
$('div')

// 相当于document.querySelectorAll
$$('#dingkaile')

// 上一次的返回值
$_

// 最近五次点击选中的dom
$0到4

```



## 隐藏元素 ：  

选中dom后，按H  可以切换元素的显示和隐藏



## 编辑dom的class list

+ 点击 .cls 可以看到这个dom上面的所有的class类名，也可以选中点掉，去除类名看效果



## dom断点

选中dom后，按右键有 Break on 其中有三种形式

+ subtree modifications 

  > 它的子组件中有什么变更，就会断在这里

+ attribute modifications

  > 自身添加一些属性，就会断

+ node removal

  > dom被移除的时候断掉



## 截图

ctrl + p   或者 command shift + p

然后输入 >screen



## 通过结构搜索dom

在element面板中进行搜索

//div/div/img   就可以找到匹配这种排列结构的dom



## 控制台中输出语句的样式定义

```js
const style = 'font-size: 20px; color: red;'
console.log('%c你好世界', 'color: red;');

var message = '你好世界';
console.log('%c' + message, style);
```



## 控制台中监听某个数值

点击小眼睛，然后输入需要监听的数据

```js
window.innerHeight

Date.now()
```



## 控制台中复制东西

copy（变量名称）



## 定义和运行代码片段

在Snipets中创建js文件。然后commad + P 

```
!文件名称
```

就可以运行该文件的js片段



## 控制台计数

```js
console.count('dingkaile')  // 每运行一次这个代码，就会+1并打印一次最新计数
console.countReset('dingkaile') // 清除计数
```



## 控制台显示调用栈信息

```js
console.trace()
```





# vsCode技巧

## 插件

+ live server
+ codegeex

## 快速写N个列表的代码

```js
ul>li{列表$}*100  // $是从1开始累计的

div{$@19}*4   // $是从19开始累计的
```



## 只能打开一个页面

```js
"workbench.editor.enablePreview": false
```





# 工程化

## 判断当前环境是不是dev环境

```json
const isDev = process.env.NODE_ENV !== 'production';
```

