# 打怪刷副本

## HTML

### 如何理解HTML语义化

+ 让人更容易读懂，增加代码可读性
+ 让搜索引擎更容易懂 （SEO搜索引擎优化）

### 块级元素和内联元素

display：block/table  独占一行 div  h1  table ul ol p

display：inline/inline-block 从左往右排，直到换行  span img  input button

## CSS

### 布局

#### 盒子模型的宽度如何计算？

offsetWidth = 内容宽度 + 内边距 + 边框 

而当加入 `box-sizing: border-box`之后，width就是offsetWidth。这会牺牲内容宽度

#### margin纵向重叠的问题。

相邻元素的margin-top和margin-bottom会发生重叠

**注意**空白内容的<p/>标签也会重叠

```html
<p>
    丁凯乐
</p>
<p></p>
<p></p>
<p></p>
<p>
	快乐星球
</p>
```

```css
p{
    margin-top: 15px,
    margin-bottom: 10px
}
```

最终结果显示的是丁凯乐和 快乐星球之间相差的是15px

原因是中间几个p是没有content的，所以只有单纯的margin；而上下margin重合了，最终结果就是15px

#### margin负值的问题 

只有top和left会影响自身的位置

right 会让自己的右边的元素左移动

bottom会让下面的元素向上移动

#### BFC理解和应用

**概念**：块级格式化上下文， 一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素

**形成BFC的常见条件：**

+ float 不是none 
+ position是absolute或者fixed
  + 绝对定位和固定定位会让元素提升为一个新的合成图层以提高渲染。所以不在同一个图层中，自然不会影响到。
    + 图层创建的主要原因有：
      + 使用了transform或opacity
      + will-change， 如果元素的will-change属性声明了某些可能变化的元素，也可能触发
      + 动画和过度
+ overflow不是visible
+ display是flex  inline-block等

**BFC的常见应用：清除浮动**

```css
.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
```

```css
.clearfix {
  overflow: hidden;
}
```



#### 圣杯布局和双飞翼布局

目的： 三栏布局，中间一栏最先加载和渲染（内容最重要）;两侧内容固定，中间内容随着宽度自适应

**实现方式**

+ 
+ 

### 响应式

#### 如何实现响应式？

+ 通过媒体查询  media-query 根据不同的屏幕尺寸设置根元素的font-size；然后是用rem基于根元素的font-size的相对单位
+ vh   vw   vmax（两者最大值） vmin(两者取最小值)

### 定位

#### absolute和relative分别依据什么定位？

#### 居中对齐有哪些方式？

##### 水平居中

inline元素： text-align: center

block元素： margin: auto

absolute 元素： left：50%； margin-left 负值（需要知道width）或者transform： translate-x: -50%

##### 垂直居中

inline元素： line-height 的值等于height值

absolute元素： top: 50% + margin-top 负值（需要直到height） 或者transform 

absolute元素： top, left, bottom, right = 0 ; margin: auto

### CSS3

#### 动画

### 图文样式

#### line-height的继承问题

+ 写具体值
  + 如40px， 那么就直接是继承这个值
+ 写数值
  + 如1.5，  那么就继承它的比例，具体值是 该元素的font-size 乘以这个比例数值
+ 写百分比
  + 如200%， 那么就在当前这个父元素中，将font-size * 200%  得到准确的象素值了之后，再相当于写具体值一样的往下继承



## JS

### 事件循环

同步代码在调用栈中顺序执行。执行结束之后。时间循环开始工作

轮询查找 callback queue 回调队列中是否有任务，如果有进入到call stack中执行

然后继续一直轮询查找



### promise

pending   —resolve变成—  fulfilled

pending  —rejec或者throw error变成— rejected

三种状态是不可逆的



#### then 和catch的链式调用

then()正常返回的是一个resolve的promise， 如果没有报错，则可以继续.then();  如果有报错的话，就不能进.then  而是进 .catch。



catch()正常返回的也是一个resolve的promise。情况同上；切记不要以为.catch()之后出来的promise 还是触发.catch



```ts
Promise.resolve().then(() => {
    console.log(1)
    thorw new Error('错误')
}).catch(() => {
    console.log(2)
}).then(() => {
    console.log(3)
})
```

注意上面这道题是有一个陷阱的

正常应该打印1 2 3  

因为在打印2之后， catch执行返回的也是一个resolve的promise。它是可以进.then的



#### async/await

坑是： await的后面，都可以看作callback里的内容，及异步。

类似于`setTimeout(() => {await 之后的代码块})` 或者 `Promise.resolve(() => {await 之后的代码块})`

```js
async function async1 () {
    console.log(1)
    await async2()
    console.log(2)
}

async function async2 () {
    console.log(3)
}

console.log(4)
async1()
console.log(5)
```

陷阱答案是： 4   1  3  2  5

正确答案是： 4   1   3  5  2



再来一道易错题：

```js
async function async1 () {
    console.log("async1 start")
    await async2()
    console.log("async1")
    await async3()
    console.log("async1 end")
}

async function async2 () {
    console.log("async2 start")
    await async3()
    console.log("async2 end")
}

async function async3 () {
    console.log("async3")
}

console.log("start")
async1()
console.log("end")
```

````css
start

async1 start

async2 start

async3

end

async2 end

async1

async3

async1 end
````

解题的关键是： await  fun()    

其中fun体内 如果 没有 await 就全部执行

有await 的话：  await之前的代码都执行，await 之后的代码都放入 event loop当中

先碰到的，先放进去



#### 宏任务和微任务

宏任务： setTimeout   setInterval   Ajax   DOM事件

​	浏览器规定的

微任务：Promise  async/await

​	由ES6语法规定的

微任务执行时机比宏任务要早



#### event loop 和DOM渲染

 每一次call stack 清空（同步代码执行完毕）

都是DOM重新渲染的机会，DOM结构如有变化则重新渲染

然后再去触发下一次Event Loop



微任务是在DOM渲染之前触发； 

宏任务是在DOM渲染之后触发



**过程**：

+ Call Stack 清空
+ 执行微任务队列
+ 进行DOM渲染
+ 执行宏任务队列



平常宽泛的过程是把 微任务队列和宏任务队列混在一起了



```js
async function async1 () {
    console.log("async1 start")
    await async2()
    console.log("async1 end")
}

async function async2 () {
    console.log("async2")
}

console.log("start")

setTimeout(() => {
    console.log("setTimeout")
})

async1()

new Promise (function (resolve) {
    console.log("promise1")
    resolve()
}).then(function () {
    console.log("promise2")
})

console.log("end")
```

```css
start

async1 start

async2

promise1

end

async1 end

promise2

setTimeout
```



#### 手写promise

属性有：

+ state
+ value
+ reason
+ resolveCallbacks
+ rejectCallbacks
+ then
+ catch

构造函数：

```js
constructor(fn) {
	const resolveHandler = (value) => {
		if (this.state === "pending") {
            this.state = "fulfilled"
            this.value = value
            this.resolveCallbacks.forEach(fn => fn(this.value))
        }
	}
	const rejectHandler = (reason) => {
		if (this.state === "pending") {
            this.state = "rejected"
            this.reason = reason
            this.rejecteCallbacks.forEach(fn => fn(this.reason))
        }
	}
	
	try {
		fn(resolveHandler, rejectHandler)
	} catch (error) {
		rejectHandler(err)
	}
}
```
**注意： 在这里要做一个类型判断，如果传入的不是一个函数的话，后面会进行不下去，所以在这里会进行默认类型转换成一个函数**

在then里面是有三种状态去处理的，如果状态已经兑现了，那么就直接执行，返回一个新的promise对象即可

如果还是pending的状态，那么才要放到队列当中等待执行

```js
then(fn1, fn2) {
	fn1 = typeof fn1 === "function" ? fn1 : (v) => v
    fn1 = typeof fn1 === "function" ? fn1 : (e) => e
    
    if (this.state === "pending") {
        const p1 = new MyPromise((resolve, reject) => {
            this.resolveCallbacks.push(() => {
                try {
                    const newValue = fn1(this.value)
                    resolve(newValue)
                } catch (err) {
                    reject(err)
                }
            })
            
            this.rejectCallbacks.push(() => {
                try {
                    const newReason = fn2(this.reason)
                    reject(err)
                } catch {
                    reject(err)
                }
            })
        })
        return p1
    }
    
    if (this.state === "fulfilled") {
        const p1 = new MyPromise((resolve, reject) => {
            try {
                const newValue = fn1(this.value)
                resolve(newValue)
            } catch (err) {
                reject(err)
            }
        })
    }
    
    if (this.state === "rejected"){
        const p1 = new MyPromise((resolve, reject) => {
            try {
                const newReason = fn2(this.reason)
                reject(newReason)
            } catch (err) {
                reject(err)
            }
        })
        return p1
    }
        
    
    
}

catch(fn) {
    return this.then(null, fn)
}
```

Promise的API

需要注意的是，**并非在Promise的定义中写，而是在其原型链上写**

```js
MyPromise.resolve = function (value) {
	return new MyPromise(resolve => resolve(value)) 
}

MyPromise.reject = function (reason) {
    return new MyPromise((resolve, reject) => reject(reason))
}
```



### 变量类型和计算 

#### 常见数据类型

常见的值类型（原始数据类型） undefined  string  number  boolean  **symbol**  **null**

常见的引用数据类型 object  array  function 

**注意： type of null 返回的是 object， 这只是语言设计中的历史遗留问题，**



#### 手写深拷贝

```js
function deepClone (obj = {}) {
	if (typeof obj !== "object" || obj == null) {
        return obj
    }
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    
    return result
}
```



#### 字符串拼接

万物加上字符串都是字符串

```js
ture + '10'   // 'ture10'
null + '10'   // 'null10'
```



#### 双等的特殊情况

```js
const obj = {x: 109}
if (obj.a == null) {}

// 相当于
if (obj.a === null || obj.a === undefined)
```



### 原型和原型链

每个class 都有显示原型prototype

每个实例都有隐式原型 `__proto__`

实例的`__proto__`指向对应class的prototype

#### 如何准确判断一个变量是不是数组

```js
const a = []
console.log(a instanceof Array)
```

#### 手写一个简单的jQuery，考虑插件和扩展性

```js
class jQuery {
    constructor(selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for(let i = 0; i < length; i++) {
            this[i] = result[i]
        }
        this.length = length
    }
    get(index) {
        return this[index]
    }
    each(fn) {
        for(let i = 0; i < this.length; i++) {
            fn(this[i])
        }
    }
    on(type, fn) {
        return this.each(elem => {
            elem.addEventListener(type, fn, false)
        })
    }
}

```



#### class的原型本质，怎么理解？

实例.`__proto__` = 原型.prototype



### 作用域和闭包

作用域就是变量的合法的适用范围，逃出作用域范围访问变量会出错

闭包是作用域应用的特殊情况，有两种表现：

+  函数作为参数被传递
+ 函数作为返回值被返回

闭包： <span style="color: red">自由变量的查找是在函数定义的地方，向上级作用域查找，而不是在执行的地方向上查找</span>

​	

#### this的不同应用场景，如何取值？

this取什么值，是在函数执行的时候决定的，而不是函数定义的时候决定的



在使用setTimeout函数的时候，如果传入的是一个function申明的函数，那么其中的this就是window

如果想要其中的this是该作用域下的this的话，就用箭头函数申明



#### 手写bind函数

这里有一个重点： <span style= "color: red">获取arguments的方式是Array.prototype.slice.call(arguments)</span>

```js
Function.prototype.myBind = fucntion () {
    args = Array.prototype.slice.call(arguments)
    const t = args.shift()
    const self = this
    return fucntion () {
        return self.apply(t, args)
    }
}
```

#### 实际开发中闭包的应用场景，举例说明

+ 隐藏数据,只提供API

  ```js
  fucntion createCache() {
      const data = {}
      return {
          set: function (key, value) {
              data[key] = value
          },
          get: function (key) {
              return data[key]
          }
      }
  }
  
  const c = createCache()
  c.set('a', 100)
  console.log(c.get('a'))
  ```

  这样可以对data进行保护，数据私有化，外部无法直接修改data，每一次访问和设置都可以人为控制



