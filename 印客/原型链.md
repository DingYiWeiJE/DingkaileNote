# 原型链

<img src="../imgs/原型链.png" style="height: 300px; float: left" alt="原型链"  />

```js
function Person() {

}

var person = new Person();

console.log(person.__proto__ == Person.prototype) // true

console.log(Person.prototype.constructor == Person) // true

console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

# 作用域

作用域是指程序源代码中定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用词法作用域`(lexical scoping`)，也就是静态作用域；**函数的作用域在函数定义的时候就决定了**；



与词法作用域相对的是动态作用域，函数的作用域在函数定义的时候就决定了

```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

结果是1 ， 因为在执行到foo的时候，就会查找foo内部有没有value变量。没有就网上找，找到了1；

因为是静态作用域，所以在定义函数的时候就已经确定了，根本不管它在执行时在哪里被调用；

如果是动态作用域的话，则会在调用函数的作用域bar函数中查找，结果找到了2，就会打印2而不是1

这就是动态作用域和静态作用域的区别。



```js
// case 1
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// case 2
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

**JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。**

第二段代码：`f` 函数被返回并在外部调用，但它仍然闭包了 `checkscope` 函数的作用域，因此返回值还是 `"local scope"`。延迟调用不会影响闭包的行为



# 变量提升

### 👀 **具体分析**

```js
function foo() {
    console.log('foo1');
}

foo();  // ?

function foo() {
    console.log('foo2');
}

foo();  // ?
```

✅ 在执行前，解释器会先把所有函数声明提升到作用域顶部，变成这样（逻辑上）：

```js
function foo() {
    console.log('foo2');
}

// 上面 foo 的定义已经覆盖了下面的

// 第一处调用
foo(); // foo2

// 第二处调用
foo(); // foo2
```

- **第一次调用 foo()** 时，实际执行的是 `console.log('foo2')`
- **第二次调用 foo()** 时，依然执行 `console.log('foo2')`



# 手写call和apply

重点在于创建一个simble，将函数赋值与context的simble属性中，调用这个simble属性，然后删除这个simble

## call

```js
Function.prototype.myCall = (context) {
  if (context == null) {
    context = window
  }
  const arg = [...arguments].slice(1)
  const fnSymbol = Symbol('fn')
  context[fnSymbol] = this
  
  const result =  context[fnSymbol](...arg)
  delete context[fnSymbol]
  return result
}
```



## apply

```js
Function.prototype.myApply = function (context, args) {
  if (context == null) {
    context = window
  }
  const fnSymbol = Symbol('fn')
  context[fnSymbol] = this
  
  const result =  context[fnSymbol](...args)
  delete context[fnSymbol]
  return result
}
```



# 手写bind

```js
Function.prototype.MyBind = function (context, ...args1) {
  const originFn = this

  function boundFn(...args2) {
    const isNew = this instanceof boundFn

    // 如果是 new 调用，则 this 为新对象；否则是 context
    const thisArg = isNew ? this : context || globalThis

    // 构造一个唯一的临时属性名（Symbol 避免冲突）
    const tempKey = Symbol('boundFunction')
    thisArg[tempKey] = originFn

    // 展开参数并调用
    const result = thisArg[tempKey](...args1, ...args2)

    // 删除临时属性
    delete thisArg[tempKey]

    return result
  }

  // 原型继承保持一致
  boundFn.prototype = Object.create(originFn.prototype)

  return boundFn
}

```





# 闭包

**能够访问自由变量（不在函数内部且不是函数参数的变量）的函数**

